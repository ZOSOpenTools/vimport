diff --git a/src/os_unix.c b/src/os_unix.c
index 237171b4f..498b9204c 100644
--- a/src/os_unix.c
+++ b/src/os_unix.c
@@ -1427,7 +1427,7 @@ mch_init(void)
 
     out_flush();
 
-#ifdef SIGTSTP
+#if defined(SIGTSTP) && !defined(__MVS__)
     // Check whether we were invoked with SIGTSTP set to be ignored. If it is
     // that indicates the shell (or program) that launched us does not support
     // tty job control and thus we should ignore that signal. If invoked as a
@@ -1681,6 +1681,263 @@ mch_input_isatty(void)
     return FALSE;
 }
 
+#ifdef __MVS__
+
+    #define MVS_DATASET_MAGIC_FD (32766)
+    #define MVS_DATASET_MAX (56) /* 44 characters plus ( plus 8 character member name plus ) plus // at the start */
+
+    #define INVALIDATED_FILE_POINTER ((void*) &((char*) 0)[1])
+    FILE* 
+zos_fopen(const char* fname, const char* mode)
+{
+   FILE* fp = fopen(fname, mode);
+   fprintf(stderr, "fopen %s with mode %s returns %p\n", fname, mode, fp);
+   return fp;
+}
+
+static int
+getmaxlrecl(const char* dataset) 
+{
+    return 80; /* change to fopen dataset, do finfo, get lrecl, -1 if unable to open */
+}
+
+struct FP2FDEntry {
+    int fd;
+    FILE* fp;
+    const char* pathname;
+};
+
+static struct FP2FDEntry static_descriptor[16] = { {0} };
+static int
+addfp(FILE* fp, const char* pathname) 
+{
+    int entry;
+    for (entry=0; entry<sizeof(static_descriptor)/sizeof(struct FP2FDEntry); ++entry) {
+	if (!static_descriptor[entry].fd) { /* found an empty slot */
+	    static_descriptor[entry].fd = MVS_DATASET_MAGIC_FD-entry;
+	    static_descriptor[entry].fp = fp;
+	    static_descriptor[entry].pathname = strdup(pathname);
+	    fprintf(stderr, "Entry %d created (fd:%d fp:%d pathname:%s)\n", entry, static_descriptor[entry].fd, static_descriptor[entry].fp, static_descriptor[entry].pathname);
+	    return static_descriptor[entry].fd;
+	}
+   }
+   fprintf(stderr, "Ran out of slots for open MVS datasets\n");
+   return 0;
+}
+
+static FILE*
+fd2fp(int fd) 
+{
+    int i;
+    for (i=0; i<sizeof(static_descriptor)/sizeof(struct FP2FDEntry); ++i) {
+	if (static_descriptor[i].fd == fd) {
+	    return static_descriptor[i].fp;
+	}
+    }
+    return NULL;
+}
+static int
+fp2fd(FILE* fp) 
+{
+    int i;
+    for (i=0; i<sizeof(static_descriptor)/sizeof(struct FP2FDEntry); ++i) {
+	if (static_descriptor[i].fp == fp) {
+	    return static_descriptor[i].fd;
+	}
+    }
+    return -1;
+}
+static int
+closefp(const char* pathname)
+{
+    int i;
+    int rc=0;
+    for (i=0; i<sizeof(static_descriptor)/sizeof(struct FP2FDEntry); ++i) {
+	fprintf(stderr, "check entry %d (pathname %p)\n", i, static_descriptor[i].pathname);
+	if (static_descriptor[i].pathname && !strcmp(static_descriptor[i].pathname, pathname)) {
+	    if (static_descriptor[i].fp && (static_descriptor[i].fp != INVALIDATED_FILE_POINTER)) {
+		fprintf(stderr, "Close open file pointer for %s\n", static_descriptor[i].pathname);
+		rc = fclose(static_descriptor[i].fp);
+		static_descriptor[i].fp = INVALIDATED_FILE_POINTER;
+		return rc;
+	    } else {
+		fprintf(stderr, "File pointer for %s found, but already closed\n", static_descriptor[i].pathname);
+	    }
+	}
+    }
+    return rc;
+}
+static FILE*
+reopenfp(int fd) 
+{
+    int i;
+    for (i=0; i<sizeof(static_descriptor)/sizeof(struct FP2FDEntry); ++i) {
+	if (static_descriptor[i].fd == fd) {
+	    if (!static_descriptor[i].fp) {
+		fprintf(stderr, "Re-open file pointer (rb) for %s\n", static_descriptor[i].pathname);
+		static_descriptor[i].fp = fopen(static_descriptor[i].pathname, "r"); /* current assumption is only needed for re-open in 'read' */
+		return static_descriptor[i].fp;
+	    }
+	}
+    }
+    return NULL;
+}
+    int
+zos_open(const char* pathname, int flags, mode_t mode)
+{
+    int fd;
+    if (pathname[0] == '/' && pathname[1] != '/' && strchr(pathname, '(')) {
+	ctrace("zos_open");
+    }
+    if (pathname[0] == '/' && pathname[1] == '/') {
+	char* parenpos;
+	int lrecl;
+	FILE* fp;
+	if (strlen(pathname) > MVS_DATASET_MAX) {
+	    errno=ENAMETOOLONG;
+	    return -1; /* fail the open */
+	}
+
+	/* this is a dataset, not a UNIX file */
+	if ((parenpos = strchr(pathname, '('))) {
+	    char pds[MVS_DATASET_MAX+1];
+	    memcpy(pds, pathname, parenpos-pathname);
+	    pds[parenpos-pathname] = '\0';
+	    /* this is a PDS member */
+	    lrecl=getmaxlrecl(pds);
+	} else {
+	    lrecl=getmaxlrecl(pathname);
+	}
+	if (lrecl < 0) {
+	    fprintf(stderr, "Dataset %s does not exist. vim failing\n", pathname);
+	    errno=ENOENT;
+	    return -1; /* fail the open if the dataset does not exist yet - restriction on vim at this time */
+	}
+	if (flags & O_RDONLY) {
+	    fp = fopen(pathname, "r"); 
+	    fprintf(stderr, "Open %s for read returns %p\n", pathname, fp);
+	} else if (flags & O_WRONLY) {
+	    if (closefp(pathname)) {
+		perror("close");
+		fprintf(stderr, "Problem closing (possible) open streams for %s\n", pathname);
+		return -1;
+	    } else {
+		fprintf(stderr, "Open handles for %s closed\n", pathname);
+	    }
+	    fp = fopen(pathname, "w");
+	    fprintf(stderr, "Open %s for write returns %p\n", pathname, fp);
+	} else {
+	    fprintf(stderr, "Only support for read or write for a dataset. flags:0x%x\n", flags);
+	    return -1;
+	}
+	if (!fp) {
+	    perror("Unable to open dataset");
+	    fprintf(stderr, "Unable to open dataset %s. vim failing\n", pathname);
+	    return -1; /* fail the open if underlying fopen fails */
+	}
+	if (addfp(fp, pathname)) {
+	    return -1;
+	}
+	fd = fp2fd(fp);
+    } else {
+	fd = open(pathname, flags, mode);
+    }
+    fprintf(stderr, "open %s with flags 0x%x and mode 0x%x returns %d\n", pathname, flags, mode, fd);
+    return fd;
+}
+
+   int
+zos_close(int fd)
+{
+    fprintf(stderr, "close %d\n", fd);
+}
+
+   int
+zos_fstat(int fd, struct stat* buf)
+{
+    int rc = fstat(fd, buf);
+    fprintf(stderr, "stat %d with buffer:%p returns %d\n", fd, buf, rc);
+    return rc;
+}
+   int
+zos_access(const char* pathname, int mode)
+{
+   int rc;
+   int acc;
+   FILE* testfp;
+   if (pathname[0] == '/' && pathname[1] == '/') {
+     if (mode == R_OK) {
+	testfp = fopen(pathname, "rb");
+	fprintf(stderr, "access check - open %s rb gives %p\n", pathname, testfp);
+        fprintf(stderr, "access %s with mode 0x%x returns %d\n", pathname, mode, ((testfp == NULL) ? -1 : 0));
+	if (testfp) {
+	    fclose(testfp);
+	    acc = 0;
+	} else { 
+	    acc = -1;
+	}
+     } else if (mode == W_OK) {
+	testfp = fopen(pathname, "rb"); /* this is wrong, but opening it for write will wipe out the contents of the file */
+	fprintf(stderr, "access check - open %s rb (attempted write check) gives %p\n", pathname, testfp);
+        fprintf(stderr, "access %s with mode 0x%x returns %d\n", pathname, mode, ((testfp == NULL) ? -1 : 0));
+	if (testfp) {
+	    fclose(testfp);
+	    acc = 0;
+	} else { 
+	    acc = -1;
+	}
+     } else {
+	fprintf(stderr, "No code to support access %s with mode 0x%x for dataset\n", pathname, mode);
+	acc = -1;
+     }
+   } else {
+     acc = access(pathname, mode);
+   }
+   return acc;
+}
+   int
+zos_read(int fd, char* buf, size_t count) {
+   FILE* altfp = fd2fp(fd);
+   int rc;
+   if (altfp == INVALIDATED_FILE_POINTER) {
+	if ((altfp = reopenfp(fd)) == NULL) {
+	    fprintf(stderr, "Unable to re-open file pointer for read\n");
+	    return -1;
+	}
+   }
+   if (altfp) {
+	rc = fread(buf, 1, count, altfp);
+	fprintf(stderr, "read %d with buffer %p count %d returns %d\n", fd, buf, count, rc);
+   } else {
+	rc = read(fd, buf, count);
+   }
+   return rc;
+}
+   int
+zos_write(int fd, char* buf, size_t count) {
+   FILE* altfp = fd2fp(fd);
+   int rc;
+   if (altfp) {
+	rc = fwrite(buf, 1, count, altfp);
+	fprintf(stderr, "write %d with buffer %p count %d returns %d\n", fd, buf, count, rc);
+   } else {
+	rc = write(fd, buf, count);
+   }
+   return rc;
+}
+
+   int 
+isdataset(int fd)
+{
+    /* super hack */
+    if (fd == MVS_DATASET_MAGIC_FD) {
+	return 1;
+    } else {
+	return 0;
+    }
+}
+#endif
+
 #ifdef FEAT_X11
 
 # if defined(ELAPSED_TIMEVAL)
@@ -2700,6 +2957,15 @@ mch_FullName(
     if ((force || !mch_isFullName(fname))
 	    && ((p = vim_strrchr(fname, '/')) == NULL || p != fname))
     {
+
+#ifdef __MVS__
+    // Always treat //<name> as an MVS dataset an leave alone
+    if (fname[0] == '/' && fname[1] == '/') {
+	vim_strncpy(buf, fname, len+1);
+	fprintf(stderr, "Copied %s to %s\n", fname, buf);
+	return OK;
+    }
+#endif
 	/*
 	 * If the file name has a path, change to that directory for a moment,
 	 * and then get the directory (and get back to where we were).
