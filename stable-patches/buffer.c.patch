diff --git a/src/buffer.c b/src/buffer.c
index 58e9718e3..d9455e40f 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -26,6 +26,7 @@
  */
 
 #include "vim.h"
+#include "dio.h"
 
 
 #ifdef FEAT_EVAL
@@ -71,6 +72,7 @@ static int	buf_free_count = 0;
 static int	top_file_num = 1;	// highest file number
 static garray_T buf_reuse = GA_EMPTY;	// file numbers to recycle
 
+
 /*
  * Return the highest possible buffer number.
  */
@@ -214,6 +216,11 @@ open_buffer(
 #ifdef FEAT_SYN_HL
 	if (old_tw != curbuf->b_p_tw)
 	    check_colorcolumn(curwin);
+    char cmd[256];
+    curbuf->b_p_tw = curbuf->reclen+1;
+    snprintf(cmd, sizeof(cmd), "setlocal colorcolumn=%d", curbuf->b_p_tw);
+    do_cmdline_cmd((char_u *)cmd);
+    do_cmdline_cmd((char_u *)"setlocal nowrap");
 #endif
 	return FAIL;
     }
@@ -1184,6 +1191,11 @@ handle_swap_exists(bufref_T *old_curbuf)
 #ifdef FEAT_SYN_HL
 	    if (old_tw != curbuf->b_p_tw)
 		check_colorcolumn(curwin);
+    char cmd[256];
+    curbuf->b_p_tw = curbuf->reclen+1;
+    snprintf(cmd, sizeof(cmd), "setlocal colorcolumn=%d", curbuf->b_p_tw);
+    do_cmdline_cmd((char_u *)cmd);
+    do_cmdline_cmd((char_u *)"setlocal nowrap");
 #endif
 	}
 	// If "old_curbuf" is NULL we are in big trouble here...
@@ -1879,6 +1891,11 @@ set_curbuf(buf_T *buf, int action)
 #ifdef FEAT_SYN_HL
 	if (old_tw != curbuf->b_p_tw)
 	    check_colorcolumn(curwin);
+    char cmd[256];
+    curbuf->b_p_tw = curbuf->reclen+1;
+    snprintf(cmd, sizeof(cmd), "setlocal colorcolumn=%d", curbuf->b_p_tw);
+    do_cmdline_cmd((char_u *)cmd);
+    do_cmdline_cmd((char_u *)"setlocal nowrap");
 #endif
     }
 }
@@ -2101,6 +2118,119 @@ buflist_new(
     if (top_file_num == 1)
 	hash_init(&buf_hashtab);
 
+  // Dataset I/O
+#ifdef __MVS__
+    if (ffname != NULL)
+    {
+      if (is_dataset(ffname)) {
+        struct DFILE* dsfile = open_dataset(ffname, NULL);
+        if (!dsfile) {
+	        semsg(_("Could not open dataset for %s"), ffname);
+          return NULL;
+        }
+
+        if (dsfile->err) {
+	        emsg(_(dsfile->msgbuff));
+          close_dataset(dsfile);
+          return NULL;
+        }
+
+        if (read_dataset(dsfile) > 0) {
+	        emsg(_(dsfile->msgbuff));
+          close_dataset(dsfile);
+          return NULL;
+        }
+
+        // Store the original dataset name
+        curbuf->dsname = vim_strsave(ffname);
+        curbuf->reclen = dsfile->reclen;
+        curbuf->is_dataset = TRUE; 
+
+        // Create a temporary file to represent the dataset 
+        ffname = vim_tempname('z', TRUE);
+
+        // Map dataset to file path
+        char file_suffix[PATH_MAX];
+        char newpath[PATH_MAX];
+        map_to_unixfile(dsfile, file_suffix);
+        snprintf(newpath, PATH_MAX, "%s-%s", ffname, file_suffix);
+
+        // Set ffname and sfname to temporary
+        sfname = vim_strsave(newpath);
+        ffname = sfname;
+
+        if (dsfile->is_binary) 
+          curbuf->b_p_bin = TRUE;
+    
+        // Default perms are writeable, unless ds is readonly
+        int perms = 0666;
+        if (dsfile->readonly)
+          perms = 0444; 
+        
+        // Create temporary file with dataset contents
+        int temp_fd;
+        if ((temp_fd = open(ffname, O_WRONLY | O_CREAT | O_TRUNC, perms)) == -1) {
+          close_dataset(dsfile);
+          close(temp_fd);
+          return NULL;
+        }
+        __disableautocvt(temp_fd);
+
+        //TODO: Create as function
+        int length_prefix = has_length_prefix(dsfile->recfm);
+        int i = 0;
+        char* data = dsfile->buffer;
+        if (length_prefix) {
+          uint16_t reclen;
+          while (i < dsfile->bufflen) {
+            memcpy(&reclen, &data[i], sizeof(reclen));
+            i += sizeof(reclen);
+            if (write(temp_fd, &data[i], reclen) != reclen) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            if (!curbuf->b_p_bin) 
+              if (write(temp_fd, "\x15", 1) != 1) {
+                close_dataset(dsfile);
+                close(temp_fd);
+                return NULL;
+              }
+            i += reclen;
+          }
+        } else {
+          while (i < dsfile->bufflen) {
+            if (write(temp_fd, &data[i], dsfile->reclen) != dsfile->reclen) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            if (!curbuf->b_p_bin)
+              if (write(temp_fd, "\x15", 1) != 1) {
+                free(dsfile->buffer);
+                close_dataset(dsfile);
+                close(temp_fd);
+                return NULL;
+              }
+            i = i + dsfile->reclen;
+          }
+        }
+
+        //free(dsfile->buffer);
+
+        // Set to untagged - Rely on the zoslib heuristic for text detection
+        __chgfdccsid(temp_fd, 0);
+
+        if (close_dataset(dsfile) > 0) {
+	        emsg(_(dsfile->msgbuff));
+          close(temp_fd);
+          return NULL;
+        }
+
+        close(temp_fd);
+      } 
+    } 
+#endif
     fname_expand(curbuf, &ffname, &sfname);	// will allocate ffname
 
     /*
@@ -2195,9 +2325,10 @@ buflist_new(
 
     if (ffname != NULL)
     {
-	buf->b_ffname = ffname;
-	buf->b_sfname = vim_strsave(sfname);
+      buf->b_ffname = ffname;
+      buf->b_sfname = vim_strsave(sfname);
     }
+   
 
     clear_wininfo(buf);
     buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);
