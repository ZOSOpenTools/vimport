diff --git a/src/buffer.c b/src/buffer.c
index 58e9718e3..5fd48012b 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -26,6 +26,7 @@
  */
 
 #include "vim.h"
+#include <_Nascii.h>
 
 
 #ifdef FEAT_EVAL
@@ -71,6 +72,21 @@ static int	buf_free_count = 0;
 static int	top_file_num = 1;	// highest file number
 static garray_T buf_reuse = GA_EMPTY;	// file numbers to recycle
 
+
+#ifdef __MVS__
+int is_dataset(const char *filename) {
+  if (filename == NULL || strlen(filename) < 2) {
+    return 0;
+  }
+
+  if (filename[0] == '/' && filename[1] == '/') {
+    return 1;
+  }
+
+  return 0;
+}
+#endif
+
 /*
  * Return the highest possible buffer number.
  */
@@ -2101,6 +2117,91 @@ buflist_new(
     if (top_file_num == 1)
 	hash_init(&buf_hashtab);
 
+  // Dataset I/O
+#ifdef __MVS__
+    if (ffname != NULL)
+    {
+      if (is_dataset(ffname)) {
+         
+        __a2e_s(ffname);
+        __ae_thread_swapmode(__AE_EBCDIC_MODE);
+        struct DFILE* dsfile = open_dataset(ffname);
+        __ae_thread_swapmode(__AE_ASCII_MODE);
+        if (!dsfile)
+          return NULL;
+
+        __ae_thread_swapmode(__AE_EBCDIC_MODE);
+        if (read_dataset(dsfile)) {
+          __ae_thread_swapmode(__AE_ASCII_MODE);
+          return NULL;
+        }
+        __ae_thread_swapmode(__AE_ASCII_MODE);
+
+        curbuf->dsname = strdup(ffname);
+        curbuf->dsfile = dsfile;
+        curbuf->is_dataset = 1; // Maybe we can just check dsfile != NULL?
+
+        // Create a temporary file to represent the dataset 
+        // TODO add LLQ as suffix
+        ffname = vim_tempname('z', TRUE);
+        sfname = ffname;
+        
+        int temp_fd;
+        //TODO: Copy permissions from dataset?
+        if ((temp_fd = open(ffname, O_WRONLY | O_CREAT | O_TRUNC, 0666)) == -1) {
+          close_dataset(dsfile);
+          close(temp_fd);
+          return NULL;
+        }
+        __disableautocvt(temp_fd);
+
+        __ae_thread_swapmode(__AE_EBCDIC_MODE);
+        int length_prefix = has_length_prefix(dsfile->recfm);
+        __ae_thread_swapmode(__AE_ASCII_MODE);
+        int i = 0;
+        char* data = dsfile->buffer;
+        if (length_prefix) {
+          uint16_t reclen;
+          while (i < dsfile->bufflen) {
+            memcpy(&reclen, &data[i], sizeof(reclen));
+            i += sizeof(reclen);
+            if (write(temp_fd, &data[i], reclen) != reclen) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            if (write(temp_fd, "\x15", 1) != 1) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            i += reclen;
+          }
+        } else {
+          while (i < dsfile->bufflen) {
+            if (write(temp_fd, &data[i], dsfile->reclen) != dsfile->reclen) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            if (write(temp_fd, "\x15", 1) != 1) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            i = i + dsfile->reclen;
+          }
+        }
+
+
+        // Set to untagged? Rely on the zoslib heuristic for text
+        __chgfdccsid(temp_fd, 0);
+        close_dataset(dsfile);
+
+        close(temp_fd);
+      } 
+    } 
+#endif
     fname_expand(curbuf, &ffname, &sfname);	// will allocate ffname
 
     /*
@@ -2195,9 +2296,10 @@ buflist_new(
 
     if (ffname != NULL)
     {
-	buf->b_ffname = ffname;
-	buf->b_sfname = vim_strsave(sfname);
+      buf->b_ffname = ffname;
+      buf->b_sfname = vim_strsave(sfname);
     }
+   
 
     clear_wininfo(buf);
     buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);
