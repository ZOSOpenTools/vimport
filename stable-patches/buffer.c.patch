diff --git a/src/buffer.c b/src/buffer.c
index 34500e4ab..c217b73c7 100644
--- a/src/buffer.c
+++ b/src/buffer.c
@@ -26,6 +26,9 @@
  */
 
 #include "vim.h"
+#ifdef __MVS__
+#include "dio.h"
+#endif
 
 
 #ifdef FEAT_EVAL
@@ -72,6 +75,7 @@ static int	buf_free_count = 0;
 static int	top_file_num = 1;	// highest file number
 static garray_T buf_reuse = GA_EMPTY;	// file numbers to recycle
 
+
 /*
  * Return the highest possible buffer number.
  */
@@ -2120,6 +2124,11 @@ buflist_new(
 {
     char_u	*ffname = ffname_arg;
     char_u	*sfname = sfname_arg;
+#ifdef __MVS__
+    int isdataset = FALSE;
+    int reclen = -1;
+    char * dsname = NULL;
+#endif
     buf_T	*buf;
 #ifdef UNIX
     stat_T	st;
@@ -2128,6 +2137,119 @@ buflist_new(
     if (top_file_num == 1)
 	hash_init(&buf_hashtab);
 
+  // Dataset I/O
+#ifdef __MVS__
+    if (ffname != NULL)
+    {
+      if (is_dataset(ffname)) {
+        struct DFILE* dsfile = open_dataset(ffname, NULL);
+        if (!dsfile) {
+	        semsg(_("Could not open dataset for %s"), ffname);
+          return NULL;
+        }
+
+        if (dsfile->err) {
+	        emsg(_(dsfile->msgbuff));
+          close_dataset(dsfile);
+          return NULL;
+        }
+
+        if (read_dataset(dsfile) > 0) {
+	        emsg(_(dsfile->msgbuff));
+          close_dataset(dsfile);
+          return NULL;
+        }
+
+        // Store the original dataset name
+        dsname = vim_strsave(ffname);
+        reclen = dsfile->reclen;
+        isdataset = TRUE; 
+
+        // Create a temporary file to represent the dataset 
+        ffname = vim_tempname('z', TRUE);
+
+        // Map dataset to file path
+        char file_suffix[PATH_MAX];
+        char newpath[PATH_MAX];
+        map_to_unixfile(dsfile, file_suffix);
+        snprintf(newpath, PATH_MAX, "%s-%s", ffname, file_suffix);
+
+        // Set ffname and sfname to temporary
+        sfname = vim_strsave(newpath);
+        ffname = sfname;
+
+        if (dsfile->is_binary) 
+          curbuf->b_p_bin = TRUE;
+    
+        // Default perms are writeable, unless ds is readonly
+        int perms = 0666;
+        if (dsfile->readonly)
+          perms = 0444; 
+        
+        // Create temporary file with dataset contents
+        int temp_fd;
+        if ((temp_fd = open(ffname, O_WRONLY | O_CREAT | O_TRUNC, perms)) == -1) {
+          close_dataset(dsfile);
+          close(temp_fd);
+          return NULL;
+        }
+        __disableautocvt(temp_fd);
+
+        //TODO: Create as function
+        int length_prefix = has_length_prefix(dsfile->recfm);
+        int i = 0;
+        char* data = dsfile->buffer;
+        if (length_prefix) {
+          uint16_t reclen;
+          while (i < dsfile->bufflen) {
+            memcpy(&reclen, &data[i], sizeof(reclen));
+            i += sizeof(reclen);
+            if (write(temp_fd, &data[i], reclen) != reclen) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            if (!curbuf->b_p_bin) 
+              if (write(temp_fd, "\x15", 1) != 1) {
+                close_dataset(dsfile);
+                close(temp_fd);
+                return NULL;
+              }
+            i += reclen;
+          }
+        } else {
+          while (i < dsfile->bufflen) {
+            if (write(temp_fd, &data[i], dsfile->reclen) != dsfile->reclen) {
+              close_dataset(dsfile);
+              close(temp_fd);
+              return NULL;
+            }
+            if (!curbuf->b_p_bin)
+              if (write(temp_fd, "\x15", 1) != 1) {
+                free(dsfile->buffer);
+                close_dataset(dsfile);
+                close(temp_fd);
+                return NULL;
+              }
+            i = i + dsfile->reclen;
+          }
+        }
+
+        //free(dsfile->buffer);
+
+        // Set to untagged - Rely on the zoslib heuristic for text detection
+        __chgfdccsid(temp_fd, 0);
+
+        if (close_dataset(dsfile) > 0) {
+	        emsg(_(dsfile->msgbuff));
+          close(temp_fd);
+          return NULL;
+        }
+
+        close(temp_fd);
+      } 
+    } 
+#endif
     fname_expand(curbuf, &ffname, &sfname);	// will allocate ffname
 
     /*
@@ -2222,9 +2344,10 @@ buflist_new(
 
     if (ffname != NULL)
     {
-	buf->b_ffname = ffname;
-	buf->b_sfname = vim_strsave(sfname);
+      buf->b_ffname = ffname;
+      buf->b_sfname = vim_strsave(sfname);
     }
+   
 
     clear_wininfo(buf);
     buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);
@@ -2271,6 +2394,7 @@ buflist_new(
 	}
 	lastbuf = buf;
 
+
 	if ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)
 	{
 	    // Recycle a previously used buffer number.  Used for buffers which
@@ -2325,6 +2449,13 @@ buflist_new(
 #endif
 
     buf->b_fname = buf->b_sfname;
+#ifdef __MVS__
+  if (isdataset) {
+    buf->is_dataset = isdataset;
+    buf->reclen = reclen;
+    buf->dsname = dsname;
+  }
+#endif
 #ifdef UNIX
     if (st.st_dev == (dev_T)-1)
 	buf->b_dev_valid = FALSE;
