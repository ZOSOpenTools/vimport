diff --git a/src/bufwrite.c b/src/bufwrite.c
index bf79ad5bf..b4e001bbb 100644
--- a/src/bufwrite.c
+++ b/src/bufwrite.c
@@ -12,6 +12,7 @@
  */
 
 #include "vim.h"
+#include <_Nascii.h>
 
 #if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)
 # include <utime.h>		// for struct utimbuf
@@ -1898,6 +1899,21 @@ restore_backup:
 		    vim_free(wfname);
 		goto fail;
 	    }
+
+#ifdef __MVS__
+      if (newfile == TRUE)
+        __tag_new_file(fd);
+      else if (st_old.st_tag.ft_ccsid == FT_UNTAGGED) {
+        __setfdccsid(fd, 0);
+        struct f_cnvrt cvtreq = {SETCVTON, 0, 1047};
+        if (curbuf->needs_conversion)
+          fcntl(fd, F_CONTROL_CVT, &cvtreq);
+        __setfdccsid(fd, 0);
+      }
+      else
+        __chgfdccsid(fd, st_old.st_tag.ft_ccsid);
+#endif
+
 	    write_info.bw_fd = fd;
 
 #if defined(UNIX)
@@ -2510,6 +2526,102 @@ restore_backup:
 	}
     }
 
+#ifdef __MVS__
+  if (curbuf->is_dataset && write_bin) {
+	  msg_puts_attr(_("\nATTENTION: Writing binary datasets it not supported.\n"),
+		    attr | MSG_HIST);
+  }
+  else if (curbuf->is_dataset) {
+    // copy from temporary file back to dataset
+    struct DFILE* dsfile = open_dataset(curbuf->dsname, NULL);
+    if (!dsfile) {
+		  errmsg = (char_u *)_("cannot open dataset");
+		  buffer = NULL;
+	    goto fail;
+    }
+
+    if (dsfile->err) {
+      errmsg = dsfile->msgbuff;
+      close_dataset(dsfile);
+      goto fail;
+    }
+
+    int length_prefix = has_length_prefix(dsfile->recfm);
+
+    // Read temporary file into record buffer
+    FILE* fp;
+    if ((fp = fopen(fname, "r")) == NULL) {
+		  errmsg = (char_u *)_("cannot open temporary file");
+		  buffer = NULL;
+      close_dataset(dsfile);
+	    goto fail;
+    }
+
+#define BUFFER_SIZE (1<<24) /* 16MB */
+#define DS_MAX_REC_SIZE (32768)
+
+    char line[DS_MAX_REC_SIZE] = {0};
+    char dsbuffer[BUFFER_SIZE] = {0};
+    int tot_size = 0;
+    uint16_t reclen = 0;
+
+    int linenum = 0;
+    while (fgets(line, sizeof(line), fp)) {
+       linenum++;
+       reclen = strlen(line) - 1; // ignore newline;
+       if (reclen > curbuf->reclen) {
+         errmsg_allocated = TRUE;
+         errmsg = alloc(300);
+         vim_snprintf((char *)errmsg, 300, "Line %d exceeded record length of %d", linenum, curbuf->reclen);
+         close_dataset(dsfile);
+         goto fail;
+       }
+       
+       __a2e_s(line);
+       if (length_prefix) {
+             if ((tot_size + sizeof(uint16_t) + reclen) > sizeof(dsbuffer)) {
+                fclose(fp);
+                errmsg = (char_u *)_("error: exceeded buffer length");
+                buffer = NULL;
+                close_dataset(dsfile);
+                goto fail;
+             }
+             memcpy(&dsbuffer[tot_size], &reclen, sizeof(uint16_t));
+             tot_size += sizeof(uint16_t);
+             memcpy(&dsbuffer[tot_size], line, reclen);
+             tot_size += reclen;
+         } else {
+             if ((tot_size + curbuf->reclen) > sizeof(dsbuffer)) {
+                 fclose(fp);
+                  errmsg = (char_u *)_("error: exceeded buffer length");
+                  buffer = NULL;
+                  close_dataset(dsfile);
+                  goto fail;
+             }
+             memcpy(&dsbuffer[tot_size], line, reclen);
+             memset(&dsbuffer[tot_size + reclen], 0x40, curbuf->reclen - reclen);
+             tot_size += curbuf->reclen;
+         }
+
+     }
+    fclose(fp);
+
+    dsfile->buffer = dsbuffer;
+    dsfile->bufflen = tot_size;
+
+    if (write_dataset(dsfile)) {
+      errmsg = dsfile->msgbuff;
+      close_dataset(dsfile);
+      goto fail;
+    }
+    if (close_dataset(dsfile)) {
+      errmsg = dsfile->msgbuff;
+      goto fail;
+    }
+}
+#endif
+
+
     // Remove the backup unless 'backup' option is set or there was a
     // conversion error.
     if (!p_bk && backup != NULL && !write_info.bw_conv_error
